先sort..
这道题还要判断重复解。combination sum |也是。用两个方法：http://www.cnblogs.com/springfor/p/3884294.html
 1. if(i>0 && candidates[i] == candidates[i-1])//deal with dupicate
                 continue; 
 2. if(!res.contains(item)) 
                res.add(new ArrayList<Integer>(item));   
这两个方法解决。 
图形解释：
http://zjalgorithm.blogspot.com/2014/07/leetcode-java-combination-sum.html
public ArrayList<ArrayList<Integer>> combinationSum2(int[] num, int target) {  
    ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();  
    if(num == null || num.length==0)  
        return res;  
    Arrays.sort(num);  
    helper(num,0,target,new ArrayList<Integer>(),res);  
    return res;  
}  
private void helper(int[] num, int start, int target, ArrayList<Integer> item,  
ArrayList<ArrayList<Integer>> res)  
{  
    if(target == 0)  
    {  
        res.add(new ArrayList<Integer>(item));  
        return;  
    }  
    if(target<0 || start>=num.length)  
        return;  
    for(int i=start;i<num.length;i++)  
    {  
        if(i>start && num[i]==num[i-1]) continue;  
        item.add(num[i]);  
        helper(num,i+1,target-num[i],item,res);  //这里是i+1不是level+1，是记录pos用的。。和combination sum差别就在i+1，因为这里不能重复
        item.remove(item.size()-1);  
    }  
}  
