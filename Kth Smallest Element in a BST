注意二叉搜索树的特性，左子树  所  有  点  的值都小于根节点，右子树的左右值都大于根节点。
采用中序遍历（左 -> 根 -> 右）即可以递增顺序访问BST中的节点，从而得到第k小的元素，时间复杂度O(k)
（最优时间复杂度应该是O(BST的高度)， 
BST的特性是，如果按照中序排列，得到的递增序；所以可以使用一个stack进行中序遍历，直到找到第K个元素； ）
1. 好理解，Inorder
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        int result=0;;
        TreeNode current = root;
        while(!stack.empty() || current !=null) {
            if(current !=null){
                stack.push(current);
                current = current.left;
            }else{
                TreeNode temp = stack.pop();
                k--;
                if(k==0) result = temp.val;
                current = temp.right;//看第一行注释
                }
        }       
        return result;
    }
}
2. follow up 问题
/*
 * Follow up:
  * What if the BST is modified (insert/delete operations) often and you need to find the kth smallest           frequently?
  * How would you optimize the kthSmallest routine?
  * Hint:
  * 1. Try to utilize the property of a BST.
  * 2. What if you could modify the BST node's structure?
  * 3. The optimal runtime complexity is O(height of BST).
  * Solution:
  * Change the structure of TreeNode, add the number of left child(cnt_left_child) and the number of right      child(cnt_right_child);
  * Insert/ delete a node of BST, update the cnt_left_child and cnt_right_child, time complexity: O(height of the tree);
  * Query the Kth smallest, just count the cnt_left_child and cnt_right_child, time complexity: O(height of the tree);
  */
public int kthSmallest(TreeNode root, int k) {
   PriorityQueue<Integer> queue = new PriorityQueue<>(k, Collections.reverseOrder());

    kthHelper(queue, root, k);
    return queue.peek();
}

private void kthHelper(PriorityQueue<Integer> queue, TreeNode root, int k) {

    if (root == null || queue.size() >= k) return;

   kthHelper(queue, root.left, k);
    if (queue.size() >= k) return;

    queue.add(root.val);

    if (root.right != null) kthHelper(queue, root.right, k);
}
