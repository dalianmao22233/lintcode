注意二叉搜索树的特性，左子树  所  有  点  的值都小于根节点，右子树的左右值都大于根节点。
1. 好理解，类似于Inorder
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        int result=0;;
        TreeNode current = root;
        while(!stack.empty() || current !=null) {
            if(current !=null){
                stack.push(current);
                current = current.left;
            }else{
                TreeNode temp = stack.pop();
                k--;
                if(k==0) result = temp.val;
                current = temp.right;//看第一行注释
                }
        }       
        return result;
    }
}
2. follow up 问题
/*
 * Follow up:
  * What if the BST is modified (insert/delete operations) often and you need to find the kth smallest           frequently?
  * How would you optimize the kthSmallest routine?
  * Hint:
  * 1. Try to utilize the property of a BST.
  * 2. What if you could modify the BST node's structure?
  * 3. The optimal runtime complexity is O(height of BST).
  * Solution:
  * Change the structure of TreeNode, add the number of left child(cnt_left_child) and the number of right      child(cnt_right_child);
  * Insert/ delete a node of BST, update the cnt_left_child and cnt_right_child, time complexity: O(height of the tree);
  * Query the Kth smallest, just count the cnt_left_child and cnt_right_child, time complexity: O(height of the tree);
  */
