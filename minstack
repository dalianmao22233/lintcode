第一种：不用数据结构，写个node类
class MinStack {  
    Node top = null;  
    public void push(int x) {  
        if (top == null) {  
            top = new Node(x);  
            top.min = x;  
        } else {  
            Node temp = new Node(x);  
            temp.next = top;  
            top = temp;  
            top.min = Math.min(top.next.min, x);  
        }  
    }  
    public void pop() {  
        top = top.next;  
        return;  
    }  
    public int top() {  
        return top == null ? 0 : top.val;  
    }  
    public int getMin() {  
        return top == null ? 0 : top.min;  
    }  
}  
class Node {  
    int val;  
    int min;  
    Node next;  
  
    public Node(int val) {  
        this.val = val;  
    }  
}  
第二种：用arraylist
Input:
push(-2),push(0),push(-1),getMin,top,pop,getMin
Output:
[-1,-1,0]
Expected:
[-2,-1,-2]


class MinStack {  
    ArrayList<Integer> stack = new ArrayList<Integer>();  
    ArrayList<Integer> minStack = new ArrayList<Integer>();  
    public void push(int x) {  
        stack.add(x);  
        if(minStack.isEmpty() || minStack.get(minStack.size()-1)>=x)  
        {  
            minStack.add(x);  
        }  
    }  
  
    public void pop() {  
        if(stack.isEmpty())  
        {  
            return;  
        }  
        int elem = stack.remove(stack.size()-1);  
        if(!minStack.isEmpty() && elem == minStack.get(minStack.size()-1))  // 维护minstack，小的值进栈
        {  
            minStack.remove(minStack.size()-1);  
        }  
    }  
  
    public int top() {  
        if(!stack.isEmpty())  
            return stack.get(stack.size()-1);  
        return 0;  
    }  
  
    public int getMin() {  
         if(!minStack.isEmpty())  
             return minStack.get(minStack.size()-1);
        //if(!stack.isEmpty()){    //由于程序是顺序执行，会执行很多操作
        //    return stack.get(stack.size()-1);
        }
        return 0;  
    }  
}  
