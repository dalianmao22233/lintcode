
http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/
1. 暴力搜索，用array.sort排一遍然后输出第K个。 O(nLogn)
public class Solution {
    public int findKthLargest(int[] nums, int k) {
        if(nums == null || nums.length == 0) return -1;
        if(k <= 0) return -1;
        Arrays.sort(nums);
        int m = 0;
        for(Integer i: nums){
            if(m == nums.length-k) {
                return nums[m];
            }
            m++;
        }
        return -1;
        
    }
}
2. min-heap: O(n + kLogn), max-heap: O(k + (n-k)*Logk)
Your input

[7,8,1,2,3,5]
4
Your stdout

pq: [7]
pq: [7, 8]
pq: [1, 8, 7]
pq: [1, 2, 7, 8]
pq: [2, 3, 7, 8]
pq: [3, 5, 7, 8]
使用小顶堆，队头就是所求得的Kth elem：

public class Solution {
    public int findKthLargest(int[] nums, int k) {
        if(nums == null || nums.length == 0 ) return 0;
        // k = k % nums.length;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int i : nums) {
            pq.offer(i);
            if(pq.size() >k ) pq.poll();
            System.out.println("pq: " + pq);
        }
        return pq.peek();
    }
}

3. quickselect:https://en.wikipedia.org/wiki/Quickselect
worst case: O(n^2), reduces the average complexity from O(n log n) to O(n), 意思是average为O(n)
public class Solution {
  
  public int findKthLargest(int[] a, int k) {
    int n = a.length;
    int p = quickSelect(a, 0, n - 1, n - k + 1);
    return a[p];
  }
  
  // return the index of the kth smallest number
  int quickSelect(int[] a, int lo, int hi, int k) {
    // use quick sort's idea
    // put nums that are <= pivot to the left
    // put nums that are  > pivot to the right
    int i = lo, j = hi, pivot = a[hi];
    while (i < j) {
      if (a[i++] > pivot) swap(a, --i, --j);
    }
    swap(a, i, hi);
    
    // count the nums that are <= pivot from lo
    int m = i - lo + 1;
    
    // pivot is the one!
    if (m == k)     return i;
    // pivot is too big, so it must be on the left
    else if (m > k) return quickSelect(a, lo, i - 1, k);
    // pivot is too small, so it must be on the right
    else            return quickSelect(a, i + 1, hi, k - m);
  }
  
  void swap(int[] a, int i, int j) {
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
  }

}
===============
This is an optimization over method 1 if QuickSort is used as a sorting algorithm in first step. 
In QuickSort, we pick a pivot element, then move the pivot element to its correct position and partition 
the array around it. The idea is, not to do complete quicksort, but stop at the point where pivot itself 
is k’th smallest element. Also, not to recur for both left and right sides of pivot, but recur for one
of them according to the position of pivot. The worst case time complexity of this method is O(n2), 
but it works in O(n) on average.
